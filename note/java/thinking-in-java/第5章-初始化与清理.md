## 第5章 初始化与清理
### this关键字
#### 在构造器中调用构造器
* 除构造器之外，编译器禁止在其他任何方法中使用`this`调用构造器。

#### static的含义
* static方法的内部不能调用非静态的方法，反过来倒可以。

### 清理：终结处理和垃圾回收
1. 对象可能不被垃圾回收；
2. 垃圾回收不等于“析构”；
3. 垃圾回收只与内存有关；

#### finalize()的用途何在
之所以要使用finalize()，是由于在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java代码中调用非Java代码的方式。

#### 你必须实施清理
记住，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

#### 垃圾回收器如何工作
* `引用计数`是一种简单但速度很慢的垃圾回收技术，每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数加1。当引用离开作用域或被置为null时，引用计数减1。垃圾回收器在含有所有对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间。**这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数不为0”的情况。**

* 在一些更快的模式当中，垃圾回收技术并非基于`引用计数`技术。它们依据的思想是：从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络被全部访问为止。也这就解决了“交互自引用的对象组”的问题。
    * 在这种方式下，Java虚拟机采用一种`自适应`的垃圾回收技术。如何处理找到存活对象，取决于不同的Java虚拟机的实现。
        * 一种做法叫`停止-复制`，先暂停程序的运行（所以它不属于后台回收模式），然后将所有存储的对象从当前堆复制到另一个堆上，没有被复制的全部都是垃圾。**当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历过程中才能被找到。**对于这种所谓的`复制式回收器`而言，效率会降低，主要有两个原因：
            * 得有两个堆，然后得在这两个分离的堆之间来回捣腾，从而维护比实际需要多一倍的空间。
            * 针对复制式回收，始终会将所有内存自一处复制到另一处，不管有没有产生垃圾。这样的复制方式是很浪费的。
        * `标记-清扫`，所依据的思路同样是从堆栈和静态存储区出发。发现存活的对象就给对象设置一个标记，这个过程不会回收任何对象。只有全部标记工作完成的时候，清理工作才会开始。清理过程中没有标记的对象将被释放，**不会发生任何复制动作。**所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。这种方式速度相当慢，但是当知道只会产生少量垃圾甚至不产生垃圾时，它的速度就很快。**这种方式也会暂停程序的运行。**
* Java虚拟机会进行监视，当所有对象都很稳定，垃圾回收器的效率降低的话，就会切换到`标记-清扫`方式；同样，Java虚拟机会跟踪`标记-清扫`的效果，要是堆空间出现很多碎片，就会切换到`停止-复制`方式。这就是`自适应`技术。
* `JIT`即时编译器技术。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得以提升。当需要装载某个类时（通常是在为该类创建第一个对象），编译器会先找到其.class文件，然后将该类的字节码装入内存。此时，有两种方案可供选择。一种是让即时编译器编译所有代码。这种方法有两个缺陷：
    * 加载动作散落在整个程序生命周期内，累加起来要花更多时间。
    * 并且会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这将导致页面调度，从而降低程序速度。
* 另一种做法称为`惰性评估`，意思是即时编译器只在必要时候才编译代码。
